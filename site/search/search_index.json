{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is MkDocs","text":"<p>MkDocs is a static site generator designed for technical documentation.</p>"},{"location":"#why-mkdocs","title":"Why MkDocs","text":"<ul> <li>Markdown-based</li> <li>Fast to build</li> <li>Version-controlled</li> <li>Easy navigation</li> </ul>"},{"location":"#typical-use-cases","title":"Typical Use Cases","text":"<ul> <li>API documentation</li> <li>Internal engineering docs</li> <li>Product documentation</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#system-purpose","title":"System Purpose","text":"<p>This system is an Inventory Management Backend designed as a single, modular monolith. Its primary purpose is to serve as a reference implementation that can be reproduced across multiple backend frameworks in order to compare architecture, developer experience, performance, and maintainability in a fair and structured way.</p> <p>The system supports common inventory-related business operations such as:</p> <ul> <li>User authentication and authorization</li> <li>Product and inventory management</li> <li>Stock movement tracking</li> <li>Order processing</li> <li>Reporting and aggregation</li> </ul> <p>While the domain is realistic, the system is intentionally constrained to keep architectural decisions clear and comparable.</p>"},{"location":"architecture/overview/#core-goals","title":"Core Goals","text":"<p>The design of this system is driven by the following goals:</p> <ol> <li>Clarity</li> <li>Make architectural boundaries explicit and understandable.</li> <li> <p>Ensure that each responsibility has a clear place in the system.</p> </li> <li> <p>Scalability (Logical, Not Physical)</p> </li> <li>Support growth in features and complexity without degrading maintainability.</li> <li> <p>Focus on modular scalability rather than horizontal scaling.</p> </li> <li> <p>Comparability Across Frameworks</p> </li> <li>Ensure the same architectural intent can be implemented consistently in different backend frameworks.</li> <li> <p>Avoid framework-specific shortcuts that would distort comparison.</p> </li> <li> <p>Approachability</p> </li> <li>Enable developers and reviewers to understand the system without deep domain knowledge.</li> <li>Favor explicit design over implicit behavior.</li> </ol>"},{"location":"architecture/overview/#target-users","title":"Target Users","text":"<p>This documentation and system architecture are intended for:</p> <ul> <li> <p>Backend Developers   Evaluating or learning different backend frameworks and architectural patterns.</p> </li> <li> <p>Technical Reviewers / Architects   Assessing trade-offs between frameworks, tooling, and design decisions.</p> </li> <li> <p>Decision Makers   Comparing backend platforms for long-term maintainability and development velocity.</p> </li> </ul> <p>The system is not optimized for end users, frontend consumption, or production-scale deployment.</p>"},{"location":"architecture/overview/#what-this-system-is-not","title":"What This System Is NOT","text":"<p>To avoid ambiguity, this system explicitly does not include:</p> <ul> <li>Microservices architecture</li> <li>Event-driven or message-based systems</li> <li>Distributed transactions</li> <li>Asynchronous job orchestration</li> <li>Domain-driven design with bounded contexts</li> <li>Framework-specific abstractions exposed at the architecture level</li> </ul> <p>These exclusions are intentional to keep the focus on core backend fundamentals.</p>"},{"location":"architecture/overview/#high-level-components","title":"High-Level Components","text":"<p>At a conceptual level, the system is composed of the following components:</p> <ul> <li> <p>API Layer   Handles HTTP requests, input validation, authentication enforcement, and response formatting.</p> </li> <li> <p>Service Layer   Encapsulates business logic and rules. Services coordinate operations across entities and repositories.</p> </li> <li> <p>Data Access Layer   Responsible for persistence, queries, and transactions. Abstracted behind repositories or models.</p> </li> <li> <p>Infrastructure Layer   Shared concerns such as configuration, logging, caching, security utilities, and database connections.</p> </li> </ul> <p>Each component has a clearly defined responsibility and a one-directional dependency flow.</p>"},{"location":"architecture/overview/#deployment-model","title":"Deployment Model","text":"<p>The system is deployed as a single backend service:</p> <ul> <li>One application process</li> <li>One database</li> <li>One runtime environment</li> </ul> <p>All modules run within the same deployment unit. Inter-module communication occurs via in-process calls, not network requests.</p> <p>This deployment model simplifies:</p> <ul> <li>Development and debugging</li> <li>Performance measurement</li> <li>Architectural comparison</li> </ul>"},{"location":"architecture/overview/#technology-stack-summary","title":"Technology Stack Summary","text":"<p>While individual implementations may vary by framework, the conceptual stack includes:</p> <ul> <li>HTTP-based REST API</li> <li>Relational database</li> <li>Token-based authentication</li> <li>In-process caching</li> <li>Centralized configuration</li> </ul> <p>Specific technologies are documented elsewhere and intentionally excluded from this architectural overview.</p>"},{"location":"architecture/overview/#design-constraints","title":"Design Constraints","text":"<p>The architecture operates under the following constraints:</p> <ul> <li> <p>Single Codebase   All functionality resides in one repository and one runtime.</p> </li> <li> <p>Explicit Boundaries   Modules must not access each other\u2019s internal state directly.</p> </li> <li> <p>Predictable Control Flow   Requests follow a consistent path from API \u2192 Service \u2192 Data Access.</p> </li> <li> <p>Repeatability   The architecture must be reproducible across different backend frameworks with minimal reinterpretation.</p> </li> </ul> <p>These constraints ensure the system remains understandable, comparable, and maintainable.</p>"},{"location":"architecture/overview/#summary-diagram-textual","title":"Summary Diagram (Textual)","text":"<p>At a high level, request flow follows this structure:</p> <pre><code>flowchart TB\n  Client[\"Client (API Consumer)\"]\n  API[\"API Layer\\n(Controllers / Routes)\"]\n  Auth[\"Authentication &amp; Authorization\"]\n  Service[\"Service Layer\\n(Business Logic)\"]\n  Data[\"Data Access Layer\\n(Models / Repositories)\"]\n  DB[\"Relational Database\"]\n\n  Client --&gt; API\n  API --&gt; Auth\n  Auth --&gt; API\n  API --&gt; Service\n  Service --&gt; Data\n  Data --&gt; DB</code></pre> <p>Cross-cutting concerns such as authentication, caching, logging, and error handling are applied consistently across all layers.</p>"}]}